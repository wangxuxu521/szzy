# 5 功能实现

## 5.1 登录相关功能实现

### 5.1.1 登录认证功能

登录认证功能采用基于 JWT 的认证机制，实现流程如下：

**前端实现**：

```javascript
// 登录请求函数
const login = async (username, password) => {
  try {
    const response = await axios.post("/api/auth/login", {
      username,
      password,
    });

    // 保存token到本地存储
    localStorage.setItem("token", response.data.token);

    // 解析用户信息
    const user = jwt_decode(response.data.token);

    return user;
  } catch (error) {
    console.error("登录失败:", error);
    throw error;
  }
};

// 请求拦截器，为每个请求添加token
axios.interceptors.request.use(
  (config) => {
    const token = localStorage.getItem("token");
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  (error) => Promise.reject(error)
);
```

**后端实现**：

```java
@RestController
@RequestMapping("/api/auth")
public class AuthController {

    @Autowired
    private AuthService authService;

    @PostMapping("/login")
    public ResponseEntity<?> login(@RequestBody LoginRequest loginRequest) {
        try {
            // 验证用户身份
            String token = authService.authenticate(loginRequest.getUsername(), loginRequest.getPassword());

            // 返回JWT令牌
            return ResponseEntity.ok(new AuthResponse(token));
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(e.getMessage());
        }
    }
}
```

### 5.1.2 权限控制功能

基于 Spring Security 实现权限控制，根据用户角色限制对不同 API 的访问：

```java
@Configuration
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            .csrf().disable()
            .authorizeRequests()
                .antMatchers("/api/auth/**").permitAll()
                .antMatchers("/api/admin/**").hasRole("ADMIN")
                .antMatchers("/api/teacher/**").hasAnyRole("ADMIN", "TEACHER")
                .antMatchers("/api/student/**").hasAnyRole("ADMIN", "TEACHER", "STUDENT")
                .anyRequest().authenticated()
            .and()
            .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)
            .and()
            .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);
    }
}
```

## 5.2 资源文件相关功能实现

### 5.2.1 资源上传功能

资源上传功能实现了文件的上传和元数据的保存：

**前端实现**：

```javascript
const uploadResource = async (formData) => {
  try {
    const response = await axios.post("/api/resources/upload", formData, {
      headers: {
        "Content-Type": "multipart/form-data",
      },
    });
    return response.data;
  } catch (error) {
    console.error("上传失败:", error);
    throw error;
  }
};
```

**后端实现**：

```java
@RestController
@RequestMapping("/api/resources")
public class ResourceController {

    @Autowired
    private ResourceService resourceService;

    @PostMapping("/upload")
    @PreAuthorize("hasAnyRole('ADMIN','TEACHER','STUDENT')")
    public ResponseEntity<?> uploadResource(@RequestParam("file") MultipartFile file,
                                           @RequestParam("title") String title,
                                           @RequestParam("description") String description,
                                           @RequestParam(value = "type", required = false) String type,
                                           @RequestParam(value = "tags", required = false) String tags,
                                           Authentication authentication) {
        try {
            User user = (User) authentication.getPrincipal();
            Resource resource = resourceService.uploadResource(file, title, description, type, tags, user.getUserId());
            return ResponseEntity.ok(resource);
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(e.getMessage());
        }
    }
}
```

### 5.2.2 资源下载功能

实现资源的下载功能，并记录下载次数：

```java
@GetMapping("/download/{resourceId}")
@PreAuthorize("isAuthenticated()")
public ResponseEntity<?> downloadResource(@PathVariable("resourceId") Integer resourceId,
                                         Authentication authentication) {
    try {
        User user = (User) authentication.getPrincipal();
        Resource resource = resourceService.getResourceById(resourceId);

        if (resource == null) {
            return ResponseEntity.notFound().build();
        }

        // 检查资源状态
        if (!"approved".equals(resource.getReviewStatus()) &&
            !user.getUserId().equals(resource.getUploaderId()) &&
            !user.getAuthorities().contains(new SimpleGrantedAuthority("ROLE_ADMIN"))) {
            return ResponseEntity.status(HttpStatus.FORBIDDEN).body("资源未通过审核或您无权下载");
        }

        // 记录下载行为
        resourceService.incrementDownloadCount(resourceId, user.getUserId());

        // 读取文件
        File file = new File(resource.getFilePath());
        InputStreamResource resource = new InputStreamResource(new FileInputStream(file));

        return ResponseEntity.ok()
            .header(HttpHeaders.CONTENT_DISPOSITION, "attachment; filename=" + URLEncoder.encode(resource.getFileName(), "UTF-8"))
            .contentLength(file.length())
            .contentType(MediaType.APPLICATION_OCTET_STREAM)
            .body(resource);
    } catch (Exception e) {
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(e.getMessage());
    }
}
```

## 5.3 资源预览功能实现

资源预览功能根据不同文件类型实现不同的预览方式：

### 5.3.1 PDF 预览实现

使用 PDF.js 实现 PDF 文件在线预览：

**前端实现**：

```javascript
import { defineComponent, ref, onMounted } from "vue";
import * as pdfjsLib from "pdfjs-dist";
import pdfjsWorker from "pdfjs-dist/build/pdf.worker.entry";

export default defineComponent({
  props: {
    pdfUrl: {
      type: String,
      required: true,
    },
  },
  setup(props) {
    const pdfContainer = ref(null);
    const currentPage = ref(1);
    const totalPages = ref(0);
    let pdfDoc = null;

    pdfjsLib.GlobalWorkerOptions.workerSrc = pdfjsWorker;

    // 渲染PDF页面
    const renderPage = async (pageNum) => {
      const page = await pdfDoc.getPage(pageNum);
      const viewport = page.getViewport({ scale: 1.5 });

      const canvas = document.createElement("canvas");
      const context = canvas.getContext("2d");
      canvas.height = viewport.height;
      canvas.width = viewport.width;

      pdfContainer.value.innerHTML = "";
      pdfContainer.value.appendChild(canvas);

      await page.render({
        canvasContext: context,
        viewport: viewport,
      }).promise;

      currentPage.value = pageNum;
    };

    // 加载PDF文档
    const loadPdf = async () => {
      try {
        pdfDoc = await pdfjsLib.getDocument(props.pdfUrl).promise;
        totalPages.value = pdfDoc.numPages;
        renderPage(1);
      } catch (error) {
        console.error("加载PDF失败:", error);
      }
    };

    // 页面导航
    const prevPage = () => {
      if (currentPage.value > 1) {
        renderPage(currentPage.value - 1);
      }
    };

    const nextPage = () => {
      if (currentPage.value < totalPages.value) {
        renderPage(currentPage.value + 1);
      }
    };

    onMounted(() => {
      loadPdf();
    });

    return {
      pdfContainer,
      currentPage,
      totalPages,
      prevPage,
      nextPage,
    };
  },
});
```

### 5.3.2 视频预览实现

使用 HTML5 的 video 标签实现视频预览：

```html
<template>
  <div class="video-player">
    <video
      :src="videoUrl"
      controls
      preload="auto"
      width="100%"
      @loadeddata="handleVideoLoaded"
      @error="handleVideoError"
    ></video>
  </div>
</template>

<script>
  export default {
    props: {
      videoUrl: {
        type: String,
        required: true,
      },
    },
    methods: {
      handleVideoLoaded(e) {
        console.log("视频加载成功");
      },
      handleVideoError(e) {
        console.error("视频加载失败:", e);
      },
    },
  };
</script>
```
